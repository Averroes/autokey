$Id$

Read INSTALL for installation instructions, and see the end of this
document for known problems.

Autokey is a text replacement tool anologous to the Mac and Windows
utilities Textpander, Texter and AutoHotKey's hotstrings, but for X11
on Linux.  The user is to keep a list of textual abbreviations in
~/.abbr.ini.  Currently these abbreviations are case-insensitive.

The program autokey.py will read the ~/.abbr.ini file on startup,
build a dictionary of abbreviations and use hotstring_keylogger to
capture all keyboard input (which must have the right /dev/input/ file
specified in the autokey.py file).  Once a recognized abbreviation
is typed, followed by a non-word character, a series of backspaces are
sent to the program, followed by a serious of KeyPress/KeyRelease
events (this is done using the python-xlib library with the xtest X11
module).  The right hand side of the abbreviations are passed to the
echo command in a subshell, so subshell and environment variables may
be used.

This is prototype code, although it has become quite usable.  It
requires python, the python-xlib package, the gksudo program and
zenity (part of the default install in Ubuntu GNU/Linux).

This program uses a keylogger written by Eddie Bell with my
modifications.  No license was provided with the code I found, the
original version is available here:

http://archives.neohapsis.com/archives/sf/linux/2005-q3/0065.html

It also assumes the gksudo command is available on your system (so that
the keylogger can be run with root permissions).

A few notes on the files...

- autokey.py is now (yet again) the main program.  It used to be the
  case that hotstring.py was the main program.  This was due to the
  fact that I took a vastly different inital approach to this program
  which I eventually scrapped.  In the mean time I experimented with
  hotstring.py and managed to create something I was quite happy with.
  I've now since merged it back into autokey.py.

- hotstring.py is now old code.  It will eventually be deleted.

- keylogger.c is my modification to Eddie Bell's excellent example
  keylogger program.  When I bumped into this I saw for the first time
  that you could capture keyboard input without patching the kernel.
  hotstring.py uses this to capture every keystroke from the keyboard.

Both of these solutions don't work for virtual terminals.  As far as I
can tell, the only solution for those is to write a kernel module.

I started this project to fill the gap in Linux text replacement tools
on the desktop.  Specifically, I wanted to see if I could come up with
something that wouldn't require patching the kernel and I have
succeeded, though not without some major bumps.

Another excellent project of this nature is Ben Kudria's Snippits
program.  It's written in Ruby and is open source as well.  Check it
out @ http://ben.kudria.net/code/snippits.  He hasn't incorporated
replace-as-you-type behavior yet, but he may have that completed
sometime in the future.  In the mean time, you can use both his
program and mine together by calling the snippit program in a subshell
from one of my abbreviations, for example:

mysnip = $(snippit mysnip)

Please let me know if you're interested in helping with the project
(programming skills aren't necessary, I need testers as well). Send
bug reports to peabodyenator@gmail.com.

KNOWN PROBLEMS
================

Currently, if an abbreviation is finished while shift, control or alt
is pressed, the expansion will happen with that key being held down.
This produces weird results, such as expansions being produced all in
caps, or menu shortcuts being taken.  I'm working on a way of turning
off the modifier keys before expanding, but until then be very careful
:).

I pass expansions to an 'echo' shell command so subshells and
environment variables can be expanded.  This has one nasty little side
effect: it limits the size of an abbreviation to Linux's ARG_MAX
(which, if Google has anything to say about it, is around 131072
bytes, or about 128KB).

Because the keylogger program echos the raw scancodes from the
keyboard, it doesn't have a way of detecting the user's keyboard
layout.  Currently, I ask the user whether they are using a qwerty or
dvorak keyboard.  Saying that this is inadequate is the under
statement of the year.  However, I haven't figured out a good way of
detecting keyboard layouts on my own.  I could use all the help I
could get here.

You must authenticate the hotstring_logger program so that it may read
from /dev/input/eventX.  This limits who may use the program to system
administrators.  I'd like to work around this, but I don't know of a
way that wouldn't be a security concern.  A likely solution would be a
udev rule apparently.

My debug output is still active, which means the input stack is echoed
to a terminal if run inside a terminal.  This means that passwords
could be echoed to the screen if the terminal is visible.  I need to
change this for my release version.

Subshell commands hang the hotstring functionality until they
complete.  That really isn't too big a deal in my book.  However, all
input is still being logged while they're running, and if any input
matches any of the abbreviations, they will be expanded upon
completion of the subshell command which is pretty nerve wracking and
confusing.

Sometimes the proper /dev/input/eventX file is not detected.  I've
made it so that the user can specify the proper event file by making
an abbreviation called eventfile and having it point to the full path
of the right event file.

There are certain problems that I don't think are solvable
with the current design...

Every once in a while the expansion will 'hiccup' and not type
properly.  Sometimes the backspacing goes too far and gobbles up data
before the point where the abbreviation was typed.  Sometimes the last
non-word character gets repeated.  Sometimes weird looking modifier
key representations get typed out instead.

These problems are because getting input from the /dev/input/* rather
than the x11 event system introduces race conditions.
hotstring_logger seems to receive and process input faster than X11 on
average under my Ubuntu GNU/Linux system.  Therefore, the user can
specific a wait_time value, in seconds, as the first argument to
autokey.py.  This does a pretty good job of working around the
problem.  I would like to completely eradicate the problem.  However,
I think it is probably impossible to prevent this with the current
design.  The fact that hotstring_logger is not synchronized with X11
events means that this problem will always be a possibility.  The only
so-called "solution" is to make it a statistical improbability by
finding good delay values for the user's typing speed and machine.
This seems like a band-aid approach to me.  I'm not happy with it.

I would prefer to do something that is synchronized with the X11 event
system.  It would solve almost every problem, including the keyboard
layout problems.  In fact, that was the first thing I looked into, but
I didn't have much luck.  Firstly, I couldn't find how to use
XSelectInput from python-xlib, which means I would have to rely on a
pipe from an X11 C program, like I am now, which may not prevent race
conditions.  The three keylogger solutions for X11 that I looked into
weren't promising.  Two of them completely didn't work on my system.
xkey.c was the only keylogger that did work and even it didn't
properly capture input events for newly created windows.  One of the
keylogger solutions seemed to be trying to work around that by
continually running an XQueryTree and adding any new windows with
XSelectInput.  However, that would seem to me to involve race
conditions as well (though much more harmless ones that will be
statistically unlikely to ever be detected by the user).  If it can be
done this way, I'm all for it.
