#!/usr/bin/env python
# -*- coding: utf-8 -*-

### BEGIN INIT INFO
# Provides:          autokey
# Required-Start:    
# Required-Stop:     
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start AutoKey daemon.
# Description:       Enable AutoKey's EvDev interface daemon.
### END INIT INFO

import sys, os, socket, dbus
from autokey import evdev, daemon
from autokey.interface import DOMAIN_SOCKET_PATH, PACKET_SIZE

PACKET_STRING = "%s,%s,%s"

class AutoKeyDaemon(daemon.Daemon):

    def __init__(self):
        logFile = "/var/log/autokey-daemon"
        if os.path.exists(logFile):
            os.remove(logFile)
        daemon.Daemon.__init__(self, '/tmp/autokey-daemon.pid', stdout=logFile, stderr=logFile)
        #daemon.Daemon.__init__(self, '/tmp/autokey-daemon.pid', stdout=sys.__stdout__.fileno(), stderr=sys.__stderr__.fileno())
        
    def get_device_paths(self):
        bus = dbus.SystemBus()
    
        hal_obj = bus.get_object ("org.freedesktop.Hal", "/org/freedesktop/Hal/Manager")
        hal = dbus.Interface (hal_obj, "org.freedesktop.Hal.Manager")
        
        udis = hal.FindDeviceByCapability ("input.keyboard")
        if not len(udis):
            sys.stdout.write("WARN: No keyboard device was found!\n")
        elif len(udis) > 1:
            sys.stdout.write("Found multiple keyboard devices\n")
        
        keyboardLocations = []
        for udisEntry in udis:
            dev_obj = bus.get_object ("org.freedesktop.Hal", udisEntry)
            dev = dbus.Interface (dev_obj, "org.freedesktop.Hal.Device")
            keyboardLocations.append(dev.GetProperty("input.device"))
        
        udis = hal.FindDeviceByCapability ("input.mouse")
        if not len(udis):
            sys.stdout.write("WARN: No mouse device was found!\n")
        elif len(udis) > 1:
            sys.stdout.write("Found multiple mouse devices\n")
        
        mouseLocations = []
        for udisEntry in udis:
            dev_obj = bus.get_object ("org.freedesktop.Hal", udisEntry)
            dev = dbus.Interface (dev_obj, "org.freedesktop.Hal.Device")
            mouseLocations.append(dev.GetProperty("input.device"))    
    
        udis = hal.FindDeviceByCapability ("input.touchpad")
        if not len(udis):
            sys.stdout.write("No touchpad device was found\n")
        elif len(udis) > 1:
            sys.stdout.write("Found multiple touchpad devices\n")
        
        touchpadLocations = []
        for udisEntry in udis:
            dev_obj = bus.get_object ("org.freedesktop.Hal", udisEntry)
            dev = dbus.Interface (dev_obj, "org.freedesktop.Hal.Device")
            touchpadLocations.append(dev.GetProperty("input.device"))    
    
    
        sys.stdout.write("Keyboards: %s\nMice: %s\nTouchpads: %s\n" % (repr(keyboardLocations), repr(mouseLocations), repr(touchpadLocations)))
        return set(keyboardLocations + mouseLocations + touchpadLocations)	
    
    def run(self):
        print "AutoKey daemon starting"
        if os.path.exists(DOMAIN_SOCKET_PATH):
            os.remove(DOMAIN_SOCKET_PATH)
        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        s.bind(DOMAIN_SOCKET_PATH)
        os.chmod(DOMAIN_SOCKET_PATH, 0777)
        print "Created domain socket"

        while True:
            s.listen(1)
            try:
                conn, addr = s.accept()
                print "Accepted connection"
            except:
                print "Fatal error while accepting connections - daemon shutting down"
                break
            
            devices = evdev.DeviceGroup(self.get_device_paths())
            sys.stdout.flush()
            sys.stderr.flush()
            
            while True:
                event = devices.next_event()
                if event is not None:
                    if event.type == "EV_KEY" and event.value != 2:
                        if event.code.startswith("KEY"):
                            # Keyboard event
                            code = event.scanCode
                            button = ''
                            state = event.value
                            
                            try:
                                self.send_packet(conn, code, button, state)
                            except:
                                sys.stdout.flush()
                                sys.stderr.flush()
                                devices.close()
                                break
    
                        elif event.code.startswith("BTN") and event.value == 1:
                            # Mouse event - only care about button press, not release
                            code = ''
                            button = event.code
                            state = event.value
    
                            try:
                                self.send_packet(conn, code, button, state)
                            except:
                                sys.stdout.flush()
                                sys.stderr.flush()
                                devices.close()
                                break

            conn.close()
            print "Connection closed"
                       
    def send_packet(self, conn, code, button, state):
        if code:
            code = self.translate_keycode(code)
        sendData = PACKET_STRING % (code, button, state)
        sendData += (PACKET_SIZE - len(sendData)) * ' '
        conn.send(sendData)
    
    def translate_keycode(self, keyCode):
        if keyCode < 151:
            keyCode += 8
        else:
            print "Got untranslatable evdev keycode: %d\n" % keyCode
            keyCode = 0
        return keyCode
    

if __name__ == "__main__":
    #daemon = AutoKeyDaemon('/tmp/autokey-daemon.pid', stdout=sys.__stdout__, stderr=sys.__stderr__)
    daemon = AutoKeyDaemon()
    if len(sys.argv) == 2:
        if 'start' == sys.argv[1]:
            daemon.start()
        elif 'stop' == sys.argv[1]:
            daemon.stop()
        elif 'restart' == sys.argv[1]:
            daemon.restart()
        else:
            print "Unknown command"
            sys.exit(2)
        sys.exit(0)
    else:
        print "usage: %s start|stop|restart" % sys.argv[0]
        sys.exit(2)
    
    sys.exit(0)
            
    
